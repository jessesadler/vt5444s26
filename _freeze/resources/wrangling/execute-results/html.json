{
  "hash": "ecf6935fd09e933cc131592487ce8ed4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Wrangling data in the tidyverse\"\nformat: html\n---\n\nWhen working with a data frame, you will usually want to modify it in some way. You may want to make some calculations based on different columns in the data or calculate some summary statistics. You may only need a subset of the data, either of the rows or columns. You might want to split the data into separate data frames or join together related data frames. Or you may need to clean up the data, changing column names, modifying values in different ways, or changing the shape of the data frame before doing your analysis and visualization. These are some of the more common tasks of **data wrangling**.[^1]\n\nWe can break these tasks into three main categories:\n\n1. Manipulating rows and columns.\n2. Joining together related data frames.\n3. Modifying the structure of a data frame.\n\n## Pipes\nBefore getting into the details of how to go about doing these data wrangling tasks using the tidyverse, we should introduce a tool that will make this process of data cleaning much easier to write and more legible to read, namely the pipe (`|>`).[^2] In doing almost any data wrangling task, you will want to perform multiple manipulations. You may want to remove some columns, *and then* remove rows with missing data, *and then* calculate the frequency of one or more column, *and then* calculate some summary statistics.\n\nThe **pipe** is the *and then*. It links together multiple functions together, taking the output from the left of the pipe and moving it to the function on the right. Using the pipe will look something like this, and remember you can think of it as *and then*:\n\n```\nhistorians |>\n  read secondary literature |>\n  read primary sources |>\n  write |>\n  do more research |>\n  rewrite |>\n  publish\n```\n\nIn this analogy `historians` take the place of the data and the various actions are the functions.\n\n## 1. Manipulating rows and columns with dplyr\nThe core set of [dplyr](https://dplyr.tidyverse.org) functions are designed to work with the pipe. They take in a data frame as their input in the first argument (named `.data`); subsequent arguments include the (unquoted) column names that are operated on; and the output is a data frame, which can be *piped* into another function. You can think of these functions as verbs to manipulate rows and columns. The core functions are:\n\n| Function      | Description                          |\n|-------------- |--------------------------------------|\n| `select()`    | Subset **columns**.                                                                                |\n| `filter()`    | Subset **rows** by conditions based on data in columns.                                            |\n| `mutate()`    | Create new columns using information from other columns.                                           |\n| `group_by()`  | Group the data by values in column such as *by village* or *by sex*.                               |\n| `summarize()` | Aggregate the data, usually on grouped data, to create summary tables.                             |\n| `arrange()`   | Arrange the order of rows by values in columns. Often used with `desc()` to reverse default order. |\n\n- To practice with these functions go to the [Wrangling data with dplyr worksheet](../worksheets/04-worksheet.qmd).\n- To read more about the core dplyr functions, see [R for Data Science: Data Transformation](https://r4ds.hadley.nz/data-transform.html).\n- For even more practice, check out the Data Carpentries, R for Social Science episode on [Data Wrangling with dplyr](https://datacarpentry.github.io/r-socialsci/03-dplyr.html).\n\nLet's quickly show how these work using the `penguins` dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  select(species, bill_len, bill_dep, sex) |> # Subset columns, not strictly necessary\n  filter(!is.na(bill_len) | !is.na(bill_dep)) |> # Remove missing values for bill measurements\n  mutate(bill_ratio = bill_dep / bill_len) |> # Create new column for ration of depth to length\n  group_by(species, sex) |> # Group the data by species and sex\n  summarize(avg_ratio = mean(bill_ratio), # Find the average bill ratio broken down by species and sex\n            n = n(), # Count the number of observations in each group\n            .groups = \"drop\") |> # Drop the remaining grouping of sex\n  arrange(desc(avg_ratio)) # Arrange the rows by the average ratio in descending order\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 4\n  species   sex    avg_ratio     n\n  <fct>     <fct>      <dbl> <int>\n1 Adelie    <NA>       0.485     5\n2 Adelie    female     0.474    73\n3 Adelie    male       0.474    73\n4 Chinstrap female     0.379    34\n5 Chinstrap male       0.377    34\n6 Gentoo    <NA>       0.319     4\n7 Gentoo    male       0.318    61\n8 Gentoo    female     0.313    58\n```\n\n\n:::\n:::\n\n\n## 2. Joining together related data frames\nA common data wrangling task is to join together related data frames. This situation can come about by the desire split up a dataset into multiple datasets to keep them clean and tidy. A common example in the humanities might be a dataset that has location names that correspond to latitude and longitude values. Instead of having latitude and longitude columns for all of our data, we might want to have a separate data frame with that information that we only need to join to the rest of the dataset when we want to create a geographic visualization. We can do this with **joins**. Let's see how it works with some data about the location of siblings at different times.\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Religious affiliation of the family members\nreligion\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 13 × 2\n   person                   religion \n   <chr>                    <chr>    \n 1 Elizabeth Zeghers        Calvinist\n 2 Jan della Faille de Oude Catholic \n 3 Andries van der Meulen   Calvinist\n 4 Daniel van der Meulen    Calvinist\n 5 Anna van der Meulen      Calvinist\n 6 Sara van der Meulen      Calvinist\n 7 Jan della Faille         Calvinist\n 8 Marten della Faille      Catholic \n 9 Carlo della Faille       Calvinist\n10 Anna della Faille        Catholic \n11 Steven della Faille      Calvinist\n12 Jacques della Faille     Calvinist\n13 Hester della Faille      Calvinist\n```\n\n\n:::\n\n```{.r .cell-code}\n# Movements of the siblings\nmovements\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 74 × 3\n   person                 place     date      \n   <chr>                  <chr>     <date>    \n 1 Andries van der Meulen Antwerp   1584-07-01\n 2 Andries van der Meulen Bremen    1585-09-01\n 3 Anna van der Meulen    Cologne   1584-07-01\n 4 Anna van der Meulen    Bremen    1588-06-01\n 5 Anna van der Meulen    Stade     1588-08-01\n 6 Anna van der Meulen    Bremen    1592-03-01\n 7 Sara van der Meulen    Antwerp   1584-07-01\n 8 Sara van der Meulen    Bremen    1585-09-01\n 9 Sara van der Meulen    Frankfurt 1586-03-01\n10 Sara van der Meulen    Cologne   1586-05-01\n# ℹ 64 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n# Latitude and longitude of the locations of the siblings\nlocations\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 21 × 3\n   location          lat   lng\n   <chr>           <dbl> <dbl>\n 1 Antwerp          51.2  4.40\n 2 Bremen           53.1  8.81\n 3 Cologne          50.9  6.96\n 4 Stade            53.6  9.48\n 5 Frankfurt        50.1  8.68\n 6 Utrecht          52.1  5.13\n 7 Leiden           52.2  4.48\n 8 Geertruidenberg  51.7  4.85\n 9 Bergen op Zoom   51.5  4.29\n10 The Hague        52.1  4.31\n# ℹ 11 more rows\n```\n\n\n:::\n:::\n\n\nThere are four main join functions. All take two data frames and join them `by` a column that is shared by both data frames. The names of the column to join by do not need to be the same, but it this case they are, namely `\"person\"`. The four functions differ in *how* they join the data frames.\n\n| Function       | Description                          |\n|--------------  |--------------------------------------|\n| `left_join()`  | Keep all observations in the first (left) data frame.                                          |\n| `right_join()` | Keep all observations in the second (right) data frame.                                        |\n| `full_join()`  | Keep all observations from *both* data frames.                                                 |\n| `inner_join()` | Only keep observations that are in *both* data frames, dropping rows that do not have a match. |\n\nLet's start with a left join between `religion` and `movements`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(religion, movements, by = \"person\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 76 × 4\n   person                   religion  place      date      \n   <chr>                    <chr>     <chr>      <date>    \n 1 Elizabeth Zeghers        Calvinist <NA>       NA        \n 2 Jan della Faille de Oude Catholic  <NA>       NA        \n 3 Andries van der Meulen   Calvinist Antwerp    1584-07-01\n 4 Andries van der Meulen   Calvinist Bremen     1585-09-01\n 5 Daniel van der Meulen    Calvinist Antwerp    1584-07-01\n 6 Daniel van der Meulen    Calvinist Middelburg 1584-08-01\n 7 Daniel van der Meulen    Calvinist Delft      1584-09-01\n 8 Daniel van der Meulen    Calvinist Haarlem    1584-12-01\n 9 Daniel van der Meulen    Calvinist Delft      1585-02-01\n10 Daniel van der Meulen    Calvinist Bremen     1585-10-01\n# ℹ 66 more rows\n```\n\n\n:::\n:::\n\n\nThe `NA`s for `place` and `date` for Elizabeth Zeghers and Jan della Faille de Oude show that there is no movement data for these individuals. We could drop these by doing a right join instead. Note the different in the number of rows. An alternative would be to switch the position of the dataframes within the `left_join()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nright_join(religion, movements, by = \"person\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 74 × 4\n   person                 religion  place      date      \n   <chr>                  <chr>     <chr>      <date>    \n 1 Andries van der Meulen Calvinist Antwerp    1584-07-01\n 2 Andries van der Meulen Calvinist Bremen     1585-09-01\n 3 Daniel van der Meulen  Calvinist Antwerp    1584-07-01\n 4 Daniel van der Meulen  Calvinist Middelburg 1584-08-01\n 5 Daniel van der Meulen  Calvinist Delft      1584-09-01\n 6 Daniel van der Meulen  Calvinist Haarlem    1584-12-01\n 7 Daniel van der Meulen  Calvinist Delft      1585-02-01\n 8 Daniel van der Meulen  Calvinist Bremen     1585-10-01\n 9 Daniel van der Meulen  Calvinist Middelburg 1586-05-01\n10 Daniel van der Meulen  Calvinist Delft      1586-06-01\n# ℹ 64 more rows\n```\n\n\n:::\n:::\n\n\nNow let's check joining the `movements` data frame to the `locations` data frame. Here we have the complication that our columns to join by have different names. We can use the `join_by()` function to tell R which columns are equivalent.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(movements, locations,\n          by = join_by(place == location))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 74 × 5\n   person                 place     date         lat   lng\n   <chr>                  <chr>     <date>     <dbl> <dbl>\n 1 Andries van der Meulen Antwerp   1584-07-01  51.2  4.40\n 2 Andries van der Meulen Bremen    1585-09-01  53.1  8.81\n 3 Anna van der Meulen    Cologne   1584-07-01  50.9  6.96\n 4 Anna van der Meulen    Bremen    1588-06-01  53.1  8.81\n 5 Anna van der Meulen    Stade     1588-08-01  53.6  9.48\n 6 Anna van der Meulen    Bremen    1592-03-01  53.1  8.81\n 7 Sara van der Meulen    Antwerp   1584-07-01  51.2  4.40\n 8 Sara van der Meulen    Bremen    1585-09-01  53.1  8.81\n 9 Sara van der Meulen    Frankfurt 1586-03-01  50.1  8.68\n10 Sara van der Meulen    Cologne   1586-05-01  50.9  6.96\n# ℹ 64 more rows\n```\n\n\n:::\n:::\n\n\nLet's now join all three data frames together using the pipe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreligion |> \n  right_join(movements, by = \"person\") |> \n  left_join(locations,\n            by = join_by(place == location))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 74 × 6\n   person                 religion  place      date         lat   lng\n   <chr>                  <chr>     <chr>      <date>     <dbl> <dbl>\n 1 Andries van der Meulen Calvinist Antwerp    1584-07-01  51.2  4.40\n 2 Andries van der Meulen Calvinist Bremen     1585-09-01  53.1  8.81\n 3 Daniel van der Meulen  Calvinist Antwerp    1584-07-01  51.2  4.40\n 4 Daniel van der Meulen  Calvinist Middelburg 1584-08-01  51.5  3.61\n 5 Daniel van der Meulen  Calvinist Delft      1584-09-01  52.0  4.36\n 6 Daniel van der Meulen  Calvinist Haarlem    1584-12-01  52.4  4.64\n 7 Daniel van der Meulen  Calvinist Delft      1585-02-01  52.0  4.36\n 8 Daniel van der Meulen  Calvinist Bremen     1585-10-01  53.1  8.81\n 9 Daniel van der Meulen  Calvinist Middelburg 1586-05-01  51.5  3.61\n10 Daniel van der Meulen  Calvinist Delft      1586-06-01  52.0  4.36\n# ℹ 64 more rows\n```\n\n\n:::\n:::\n\n\nNow are data would be ready to map. This ability to quickly join together related datasets makes it possible to greatly simplify the structure of the data if you are in the situation of creating your dataset. Instead of writing the latitude and longitude over and over again, possibly introducing copy and paste errors, you can have it in one place and only use it when necessary.\n\nDownload the three data frames to play around with them: [religion](../datasets/religion.csv), [movements](../datasets/movements.csv), and [locations](../datasets/locations.csv).\n\n### Resources\n- A good overview is provided by the [Joins](https://r4ds.hadley.nz/joins.html) chapter of *R for Data Science*.\n- See also the [Two-table verbs article](https://dplyr.tidyverse.org/articles/two-table.html) in the dplyr package.\n\n## 3. Modifying the structure of a data frame\nA second task you may face is needing to alter the structure of your data to make it tidy. This is the specialty of the [tidyr](https://tidyr.tidyverse.org/index.html) package. It takes us back to the principles of tidy data:\n\n1. Each variable is a column; each column is a variable.\n2. Each observation is a row; each row is an observation.\n3. Each value is a cell; each cell is a single value.\n\n### Wide to long\nHowever, data is not always tidy; sometimes for good reason. For instance, in collecting data it might be easier to create a data frame in a **wide** format in which variable values are spread out in separate columns. For instance, a data frame with the counts for each penguin species by year.\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_wide\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n  species   `2007` `2008` `2009`\n  <fct>      <int>  <int>  <int>\n1 Adelie        50     50     52\n2 Chinstrap     26     18     24\n3 Gentoo        34     46     44\n```\n\n\n:::\n:::\n\n\nTo make this data frame tidy we need to create a new column for year and a new column for the values in the current year columns, in this case count. to do this we use the `pivot_longer()` function. The key arguments for the function are:\n\n- `cols`: Columns to pivot into a longer format, or alternatively the columns to disregard in pivoting using the not operator (`!`).\n- `names_to`: The name new column or columns to create from the information stored in the column names specified by the `cols` argument. Should be a name in quotation marks.\n- `values_to`: The name of the column to create from the data stored in cell values. Should be a name in quotation marks.\n\nLet's see how this works.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_wide |> \n  pivot_longer(\n    cols = !species,\n    names_to = \"year\",\n    values_to = \"count\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 3\n  species   year  count\n  <fct>     <chr> <int>\n1 Adelie    2007     50\n2 Adelie    2008     50\n3 Adelie    2009     52\n4 Chinstrap 2007     26\n5 Chinstrap 2008     18\n6 Chinstrap 2009     24\n7 Gentoo    2007     34\n8 Gentoo    2008     46\n9 Gentoo    2009     44\n```\n\n\n:::\n:::\n\n\n### Long to wide\nGoing from a wider format to a longer format is the more common transformation, but you may find yourself in the situation of wanting to use a wider format to present your data in a table. We can reverse what we did with `pivot_longer()` using `pivot_wider()`. The key arguments mirror those for `pivot_longer()`:\n\n- `names_from`: Column used to create new column names. Does not need to be in quotes because it is a column in the data.\n- `values_from`: Column used to create cell values. Does not need to be in quotes because it is a column in the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_long |> \n  pivot_wider(\n    names_from = year,\n    values_from = count)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n  species   `2007` `2008` `2009`\n  <fct>      <int>  <int>  <int>\n1 Adelie        50     50     52\n2 Chinstrap     26     18     24\n3 Gentoo        34     46     44\n```\n\n\n:::\n:::\n\n\n### Resources\nThese examples provide a short glimpse of the ways that you can manipulate the structure of data frames with tidyr. For more information see:\n\n- A good overview is provided by the [Data tidying](https://r4ds.hadley.nz/data-tidy.html) chapter of *R for Data Science*.\n- The [tidy data article](https://tidyr.tidyverse.org/articles/tidy-data.html) in the tidyr package. It is a code heavy version of Hadley Wickham's [Tidy data paper](https://vita.had.co.nz/papers/tidy-data.html).\n- The [Pivoting article](https://tidyr.tidyverse.org/articles/pivot.html) in the tidyr package.\n- For even more practice, check out the Data Carpentries, R for Social Science episode on [Data Wrangling with tidyr](https://datacarpentry.github.io/r-socialsci/04-tidyr.html).\n\n\n[^1]: Hadley Wickham, \"Tidy Data,\" *Journal of Statistical Software* 59, no. 10 (2014), https://doi.org/10.18637/jss.v059.i10.\n\n[^2]: This is the base R pipe that was introduced in R 4.1 in 2021. You may also see the magrittr pipe (`%>%`). Their functionality is essentially the same. The base R pipe is created using the pipe character (Shift + backslash) and the greater than sign. You can quickly type it out with the keyboard shortcut `Cmd/Ctrl + Shift + M`. To setup RStudio to use the base pipe with this keyboard shortcut, see [Setting up RStudio for success](rstudio-setup.qmd#other-tweaks).",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}